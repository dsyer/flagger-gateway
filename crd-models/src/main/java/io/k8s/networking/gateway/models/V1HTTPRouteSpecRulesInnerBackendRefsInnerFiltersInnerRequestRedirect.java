/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.27.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.k8s.networking.gateway.models;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.k8s.networking.gateway.models.V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirectPath;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import io.kubernetes.client.openapi.JSON;

/**
 * RequestRedirect defines a schema for a filter that responds to the request with an HTTP redirection.   Support: Core
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect {
  public static final String SERIALIZED_NAME_HOSTNAME = "hostname";
  @SerializedName(SERIALIZED_NAME_HOSTNAME)
  private String hostname;

  public static final String SERIALIZED_NAME_PATH = "path";
  @SerializedName(SERIALIZED_NAME_PATH)
  private V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirectPath path;

  public static final String SERIALIZED_NAME_PORT = "port";
  @SerializedName(SERIALIZED_NAME_PORT)
  private Integer port;

  /**
   * Scheme is the scheme to be used in the value of the &#x60;Location&#x60; header in the response. When empty, the scheme of the request is used.   Scheme redirects can affect the port of the redirect, for more information, refer to the documentation for the port field of this filter.   Note that values may be added to this enum, implementations must ensure that unknown values will not cause a crash.   Unknown values here must result in the implementation setting the Accepted Condition for the Route to &#x60;status: False&#x60;, with a Reason of &#x60;UnsupportedValue&#x60;.   Support: Extended
   */
  @JsonAdapter(SchemeEnum.Adapter.class)
  public enum SchemeEnum {
    HTTP("http"),
    
    HTTPS("https");

    private String value;

    SchemeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SchemeEnum fromValue(String value) {
      for (SchemeEnum b : SchemeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SchemeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SchemeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SchemeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SchemeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SchemeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SCHEME = "scheme";
  @SerializedName(SERIALIZED_NAME_SCHEME)
  private SchemeEnum scheme;

  public static final String SERIALIZED_NAME_STATUS_CODE = "statusCode";
  @SerializedName(SERIALIZED_NAME_STATUS_CODE)
  private Integer statusCode;

  public V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect() {
  }

  public V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect hostname(String hostname) {
    this.hostname = hostname;
    return this;
  }

   /**
   * Hostname is the hostname to be used in the value of the &#x60;Location&#x60; header in the response. When empty, the hostname in the &#x60;Host&#x60; header of the request is used.   Support: Core
   * @return hostname
  **/
  @jakarta.annotation.Nullable
  public String getHostname() {
    return hostname;
  }

  public void setHostname(String hostname) {
    this.hostname = hostname;
  }


  public V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect path(V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirectPath path) {
    this.path = path;
    return this;
  }

   /**
   * Get path
   * @return path
  **/
  @jakarta.annotation.Nullable
  public V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirectPath getPath() {
    return path;
  }

  public void setPath(V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirectPath path) {
    this.path = path;
  }


  public V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect port(Integer port) {
    this.port = port;
    return this;
  }

   /**
   * Port is the port to be used in the value of the &#x60;Location&#x60; header in the response.   If no port is specified, the redirect port MUST be derived using the following rules:   * If redirect scheme is not-empty, the redirect port MUST be the well-known   port associated with the redirect scheme. Specifically \&quot;http\&quot; to port 80   and \&quot;https\&quot; to port 443. If the redirect scheme does not have a   well-known port, the listener port of the Gateway SHOULD be used. * If redirect scheme is empty, the redirect port MUST be the Gateway   Listener port.   Implementations SHOULD NOT add the port number in the &#39;Location&#39; header in the following cases:   * A Location header that will use HTTP (whether that is determined via   the Listener protocol or the Scheme field) _and_ use port 80. * A Location header that will use HTTPS (whether that is determined via   the Listener protocol or the Scheme field) _and_ use port 443.   Support: Extended
   * minimum: 1
   * maximum: 65535
   * @return port
  **/
  @jakarta.annotation.Nullable
  public Integer getPort() {
    return port;
  }

  public void setPort(Integer port) {
    this.port = port;
  }


  public V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect scheme(SchemeEnum scheme) {
    this.scheme = scheme;
    return this;
  }

   /**
   * Scheme is the scheme to be used in the value of the &#x60;Location&#x60; header in the response. When empty, the scheme of the request is used.   Scheme redirects can affect the port of the redirect, for more information, refer to the documentation for the port field of this filter.   Note that values may be added to this enum, implementations must ensure that unknown values will not cause a crash.   Unknown values here must result in the implementation setting the Accepted Condition for the Route to &#x60;status: False&#x60;, with a Reason of &#x60;UnsupportedValue&#x60;.   Support: Extended
   * @return scheme
  **/
  @jakarta.annotation.Nullable
  public SchemeEnum getScheme() {
    return scheme;
  }

  public void setScheme(SchemeEnum scheme) {
    this.scheme = scheme;
  }


  public V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect statusCode(Integer statusCode) {
    this.statusCode = statusCode;
    return this;
  }

   /**
   * StatusCode is the HTTP status code to be used in response.   Note that values may be added to this enum, implementations must ensure that unknown values will not cause a crash.   Unknown values here must result in the implementation setting the Accepted Condition for the Route to &#x60;status: False&#x60;, with a Reason of &#x60;UnsupportedValue&#x60;.   Support: Core
   * @return statusCode
  **/
  @jakarta.annotation.Nullable
  public Integer getStatusCode() {
    return statusCode;
  }

  public void setStatusCode(Integer statusCode) {
    this.statusCode = statusCode;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect v1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect = (V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect) o;
    return Objects.equals(this.hostname, v1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect.hostname) &&
        Objects.equals(this.path, v1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect.path) &&
        Objects.equals(this.port, v1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect.port) &&
        Objects.equals(this.scheme, v1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect.scheme) &&
        Objects.equals(this.statusCode, v1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect.statusCode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(hostname, path, port, scheme, statusCode);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect {\n");
    sb.append("    hostname: ").append(toIndentedString(hostname)).append("\n");
    sb.append("    path: ").append(toIndentedString(path)).append("\n");
    sb.append("    port: ").append(toIndentedString(port)).append("\n");
    sb.append("    scheme: ").append(toIndentedString(scheme)).append("\n");
    sb.append("    statusCode: ").append(toIndentedString(statusCode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("hostname");
    openapiFields.add("path");
    openapiFields.add("port");
    openapiFields.add("scheme");
    openapiFields.add("statusCode");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect is not found in the empty JSON string", V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("hostname") != null && !jsonObj.get("hostname").isJsonNull()) && !jsonObj.get("hostname").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hostname` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hostname").toString()));
      }
      // validate the optional field `path`
      if (jsonObj.get("path") != null && !jsonObj.get("path").isJsonNull()) {
        V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirectPath.validateJsonElement(jsonObj.get("path"));
      }
      if ((jsonObj.get("scheme") != null && !jsonObj.get("scheme").isJsonNull()) && !jsonObj.get("scheme").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `scheme` to be a primitive type in the JSON string but got `%s`", jsonObj.get("scheme").toString()));
      }
      // validate the optional field `scheme`
      if (jsonObj.get("scheme") != null && !jsonObj.get("scheme").isJsonNull()) {
        SchemeEnum.validateJsonElement(jsonObj.get("scheme"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect.class));

       return (TypeAdapter<T>) new TypeAdapter<V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect>() {
           @Override
           public void write(JsonWriter out, V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect
  * @throws IOException if the JSON string is invalid with respect to V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect
  */
  public static V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect.class);
  }

 /**
  * Convert an instance of V1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

